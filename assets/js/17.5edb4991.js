(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{284:function(e,t,n){"use strict";n.r(t);var r=n(0),a=Object(r.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Babel的三个主要处理步骤分别是：解析（parse）、转换（transform）、生成（generate）。")]),e._v(" "),n("p",[n("strong",[e._v("解析")])]),e._v(" "),n("p",[e._v("解析步骤主要是接受源代码并输出抽象语法树（AST）。此步骤主要由"),n("code",[e._v("@babel/parser")]),e._v("（原"),n("code",[e._v("Babylon")]),e._v("）负责解析和理解js代码，输出对应的AST。")]),e._v(" "),n("p",[n("strong",[e._v("转换")])]),e._v(" "),n("p",[e._v("转换步骤主要是接受AST，并对其进行遍历，在此过程中会进行分析和修改AST，这也是Babel插件主要工作的地方。此步骤主要用到"),n("code",[e._v("@babel/traverse")]),e._v("和"),n("code",[e._v("@babel/types")]),e._v("两个包。")]),e._v(" "),n("p",[n("strong",[e._v("生成")])]),e._v(" "),n("p",[e._v("生成步骤主要是将（经过一系列转换之后的）AST再转换为正常的字符串代码。此步骤主要由"),n("code",[e._v("@babel/generator")]),e._v("深度优先遍历整个AST，然后构建可以表示转换后代码的字符串。")]),e._v(" "),n("h1",{attrs:{id:"抽象语法树（ast）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#抽象语法树（ast）","aria-hidden":"true"}},[e._v("#")]),e._v(" 抽象语法树（AST）")]),e._v(" "),n("p",[e._v("学过《编译原理》的童鞋应该都知道AST，即使不知道也没关系，我们可以通过"),n("code",[e._v("astexplorer")]),e._v("在线查看。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-images.githubusercontent.com/11884369/55702696-f13ca600-5a09-11e9-9cff-adec9a70821a.png",alt:"astexplorer"}})]),e._v(" "),n("p",[e._v("如上所示。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function square(n) {\n  return n * n;\n}\n")])])]),n("p",[e._v("这段代码可以表示成如下所示的一棵树：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('{\n  type: "FunctionDeclaration",\n  id: {\n    type: "Identifier",\n    name: "square"\n  },\n  params: [{\n    type: "Identifier",\n    name: "n"\n  }],\n  body: {\n    type: "BlockStatement",\n    body: [{\n      type: "ReturnStatement",\n      argument: {\n        type: "BinaryExpression",\n        operator: "*",\n        left: {\n          type: "Identifier",\n          name: "n"\n        },\n        right: {\n          type: "Identifier",\n          name: "n"\n        }\n      }\n    }]\n  }\n}\n')])])]),n("blockquote",[n("p",[e._v("可以使用json对象表示AST，出于简化的目的，上面移除了部分属性")])]),e._v(" "),n("p",[e._v("这个AST中的每一层结构叫做"),n("code",[e._v("节点(node)")]),e._v("，一个AST可以由单一的节点或是成百上千个节点构成。 它们组合在一起可以描述用于静态分析的程序语法。")]),e._v(" "),n("p",[e._v("每一个节点都有如下所示的接口（Interface）：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Node {\n  type: string;\n}\n")])])]),n("p",[e._v('字符串形式的 type 字段表示节点的类型（如： "FunctionDeclaration"，"Identifier"，或 "BinaryExpression"）。 每一种类型的节点定义了一些附加属性用来进一步描述该节点类型。')]),e._v(" "),n("p",[e._v("Babel插件就是对这些节点进行添加、更新和删除。")]),e._v(" "),n("h1",{attrs:{id:"路径（path）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#路径（path）","aria-hidden":"true"}},[e._v("#")]),e._v(" 路径（Path）")]),e._v(" "),n("p",[e._v("AST能够表示语法的结构，但是我们对节点进行操作时，更多的是希望获得节点之间的联系。")]),e._v(" "),n("p",[n("strong",[e._v("Path")]),e._v("是表示两个节点之间连接的对象。")]),e._v(" "),n("p",[e._v("例如，如果有下面这样一个节点及其子节点︰")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('{\n  type: "FunctionDeclaration",\n  id: {\n    type: "Identifier",\n    name: "square"\n  },\n  ...\n}\n')])])]),n("p",[e._v("将子节点"),n("code",[e._v("Identifier")]),e._v("表示为一个路径（Path）的话，看起来是这样的：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('{\n  "parent": {\n    "type": "FunctionDeclaration",\n    "id": {...},\n    ....\n  },\n  "node": {\n    "type": "Identifier",\n    "name": "square"\n  }\n}\n')])])]),n("p",[e._v("同时它还包含关于该路径的其他元数据：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('{\n  "parent": {...},\n  "node": {...},\n  "hub": {...},\n  "contexts": [],\n  "data": {},\n  "shouldSkip": false,\n  "shouldStop": false,\n  "removed": false,\n  "state": null,\n  "opts": null,\n  "skipKeys": null,\n  "parentPath": null,\n  "context": null,\n  "container": null,\n  "listKey": null,\n  "inList": false,\n  "parentKey": null,\n  "key": null,\n  "scope": null,\n  "type": null,\n  "typeAnnotation": null\n}\n')])])]),n("p",[e._v("在某种意义上，路径是一个节点在树中的位置以及关于该节点各种信息的响应式"),n("code",[e._v("Reactive")]),e._v("表示。路径对象还包含添加、更新、移动和删除节点有关的其他很多方法，当你调用一个修改树的方法后，路径信息也会被更新。")]),e._v(" "),n("p",[n("code",[e._v("@babel/traverse")]),e._v("这个独立的包对AST进行遍历，解析出整个树的"),n("code",[e._v("path")]),e._v("，并更新节点。")]),e._v(" "),n("h1",{attrs:{id:"访问者（visitor）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#访问者（visitor）","aria-hidden":"true"}},[e._v("#")]),e._v(" 访问者（visitor）")]),e._v(" "),n("p",[n("code",[e._v("@babel/traverse")]),e._v("遍历AST时，会依次进入每个节点。")]),e._v(" "),n("p",[e._v("假设有如下AST结构：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("- FunctionDeclaration\n  - Identifier (id)\n  - Identifier (params[0])\n  - BlockStatement (body)\n    - ReturnStatement (body)\n      - BinaryExpression (argument)\n        - Identifier (left)\n        - Identifier (right)\n")])])]),n("p",[e._v("则遍历过程如下：")]),e._v(" "),n("ul",[n("li",[e._v("进入 "),n("code",[e._v("FunctionDeclaration")]),e._v(" "),n("ul",[n("li",[e._v("进入 "),n("code",[e._v("Identifier (id)")])]),e._v(" "),n("li",[e._v("走到尽头")]),e._v(" "),n("li",[e._v("退出 "),n("code",[e._v("dentifier (id)")])]),e._v(" "),n("li",[e._v("进入 "),n("code",[e._v("Identifier (params[0])")])]),e._v(" "),n("li",[e._v("走到尽头")]),e._v(" "),n("li",[e._v("退出 "),n("code",[e._v("Identifier (params[0])")])]),e._v(" "),n("li",[e._v("进入 "),n("code",[e._v("BlockStatement (body)")])]),e._v(" "),n("li",[e._v("进入 "),n("code",[e._v("ReturnStatement (body)")]),e._v(" "),n("ul",[n("li",[e._v("进入 "),n("code",[e._v("BinaryExpression (argument)")])]),e._v(" "),n("li",[e._v("进入 "),n("code",[e._v("Identifier (left)")]),e._v(" "),n("ul",[n("li",[e._v("走到尽头")])])]),e._v(" "),n("li",[e._v("退出 "),n("code",[e._v("Identifier (left)")])]),e._v(" "),n("li",[e._v("进入 "),n("code",[e._v("Identifier (right)")]),e._v(" "),n("ul",[n("li",[e._v("走到尽头")])])]),e._v(" "),n("li",[e._v("退出 "),n("code",[e._v("Identifier (right)")])]),e._v(" "),n("li",[e._v("退出 "),n("code",[e._v("BinaryExpression (argument)")])])])]),e._v(" "),n("li",[e._v("退出 "),n("code",[e._v("ReturnStatement (body)")])]),e._v(" "),n("li",[e._v("退出 "),n("code",[e._v("BlockStatement (body)")])])])]),e._v(" "),n("li",[e._v("退出 "),n("code",[e._v("FunctionDeclaration")])])]),e._v(" "),n("p",[e._v("当我们说进入某一个节点，实际上是说我们在"),n("strong",[e._v("访问")]),e._v("他们。")]),e._v(" "),n("p",[e._v("访问者简单的说就是一个对象，它定义了在树状机构的遍历中，如何获取节点的方法。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const MyVisitor = {\n  Identifier() {\n    console.log("Called!");\n  }\n};\n')])])]),n("p",[e._v("这是一个简单的访问者，把它用于遍历中时，每当在树中遇见一个"),n("code",[e._v("Identifier")]),e._v("的时候会调用"),n("code",[e._v("Identifier()")]),e._v("方法。")]),e._v(" "),n("p",[e._v("所以在下面的代码中"),n("code",[e._v("Identifier()")]),e._v("方法会被调用四次（包括"),n("code",[e._v("square")]),e._v("在内，总共有四个"),n("code",[e._v("Identifier")]),e._v("）。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function square(n) {\n  return n * n;\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("traverse(ast, MyVisitor);\nCalled!\nCalled!\nCalled!\nCalled!\n")])])]),n("p",[e._v("这些调用都发生在进入节点时，不过有时候我们也可以在退出时调用访问者方法。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const MyVisitor = {\n  Identifier: {\n    enter() {\n      console.log("Entered!");\n    },\n    exit() {\n      console.log("Exited!");\n    }\n  }\n};\n')])])]),n("p",[e._v("因此，对于一个具体的节点我们有两次访问的机会。")]),e._v(" "),n("p",[e._v("当你有一个"),n("code",[e._v("Identifier()")]),e._v("成员方法的访问者时，你实际上是在访问路径而非节点。通过这种方式，你操作的就是节点的响应式表示（译注：即路径）而非节点本身。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const parser = require("@babel/parser");\nconst traverse = require("@babel/traverse").default;\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\nconst MyVisitor = {\n    Identifier: {\n      enter(path) {\n        console.log(`${path.node.name} Entered!`);\n      },\n      exit(path) {\n        console.log(`${path.node.name} Exited!`);\n      }\n    }\n  };\n\ntraverse(ast, MyVisitor);\n')])])]),n("p",[e._v("输出结果如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Identifier square Entered!\nIdentifier square Exited!\nIdentifier n Entered!\nIdentifier n Exited!\nIdentifier n Entered!\nIdentifier n Exited!\nIdentifier n Entered!\nIdentifier n Exited!\n")])])]),n("h1",{attrs:{id:"初窥插件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初窥插件","aria-hidden":"true"}},[e._v("#")]),e._v(" 初窥插件")]),e._v(" "),n("p",[e._v("从上面的示例我们已经知道如何访问节点，现在我们可以操作节点。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const parser = require("@babel/parser");\nconst traverse = require("@babel/traverse").default;\nconst generate = require("@babel/generator").default;\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\nconst MyVisitor = {\n    enter(path) { // enter会在每个节点进入时执行\n        if (\n            path.node.type === "Identifier" &&\n            path.node.name === "n"\n        ) {\n            path.node.name = "x";\n        }\n    }\n};\n\ntraverse(ast, MyVisitor);\n\nconst result = generate(ast);\n\nconsole.log(result.code);\n')])])]),n("p",[e._v("输出结果：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function square(x) {\n  return x * x;\n}\n")])])]),n("p",[e._v("这便是Babel插件的基本运行原理。")]),e._v(" "),n("h1",{attrs:{id:"babel-types工具库"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#babel-types工具库","aria-hidden":"true"}},[e._v("#")]),e._v(" "),n("code",[e._v("@Babel/types")]),e._v("工具库")]),e._v(" "),n("p",[n("code",[e._v("@Babel/Types")]),e._v("模块是一个用于 AST 节点的"),n("code",[e._v("Lodash")]),e._v("式工具库，它包含了构造、验证以及变换 AST 节点的方法。 该工具库包含考虑周到的工具方法，对编写处理AST逻辑非常有用。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const t = require("@babel/types");\n\n...\n\nconst MyVisitor = {\n    enter(path) {\n        if (t.isIdentifier(path.node, { name: "n" })) {\n            path.replaceWith(t.identifier(\'x\'))\n          }\n    }\n};\n\n...\n')])])]),n("p",[e._v("这里使用"),n("code",[e._v('isIdentifier(path.node, { name: "n" })')]),e._v("验证值为"),n("code",[e._v("n")]),e._v("的"),n("code",[e._v("Identifier")]),e._v("节点。然后使用"),n("code",[e._v("identifier('x')")]),e._v("创建一个值为"),n("code",[e._v("x")]),e._v("的节点进行替换。")]),e._v(" "),n("p",[e._v("输出结果一致。")]),e._v(" "),n("p",[n("code",[e._v("@Babel/Types")]),e._v("还提供了多种节点类型的构造、验证方法（eg："),n("code",[e._v("binaryExpression")]),e._v("、"),n("code",[e._v("returnStatement")]),e._v("、"),n("code",[e._v("classDeclaration")]),e._v("），详细请查阅文档。")]),e._v(" "),n("p",[e._v("判断节点类型时，在类型名称前加"),n("code",[e._v("is")]),e._v("，然后将类型名称第一个字母变成大写，例如"),n("code",[e._v("isIdentifier")]),e._v("，该方法还有另外一个版本"),n("code",[e._v("assetIdentifier")]),e._v("(抛出异常，而不是返回true 与 false)。")]),e._v(" "),n("p",[e._v("创建一个类型节点时（用于插入AST中，或者替换AST中的节点），直接调用节点类型函数，类型名称第一个字母小写，例如"),n("code",[e._v("identifier('x')")]),e._v("。")]),e._v(" "),n("h1",{attrs:{id:"转换操作函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#转换操作函数","aria-hidden":"true"}},[e._v("#")]),e._v(" 转换操作函数")]),e._v(" "),n("p",[n("code",[e._v("Path")]),e._v("对象提供了添加、更新、移动和删除等一系列节点操作方法。")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("get")]),e._v("：获取子节点属性")]),e._v(" "),n("li",[n("code",[e._v("isReferencedIdentifier")]),e._v("：检查标示符（Identifier）是否被引用")]),e._v(" "),n("li",[n("code",[e._v("findParent")]),e._v("：向父路径搜索节点")]),e._v(" "),n("li",[n("code",[e._v("find")]),e._v("：向父节点搜索节点，并且搜索本节点")]),e._v(" "),n("li",[n("code",[e._v("getFunctionParent")]),e._v("：查找最接近的父函数或程序")]),e._v(" "),n("li",[n("code",[e._v("getStatementParent")]),e._v("：向上遍历语法树，直到找到在列表中的父节点路径")]),e._v(" "),n("li",[n("code",[e._v("inList")]),e._v("：判断路径是否有同级节点")]),e._v(" "),n("li",[n("code",[e._v("getSibling")]),e._v("：获得同级路径")]),e._v(" "),n("li",[n("code",[e._v("key")]),e._v("：获取路径所在容器的索引")]),e._v(" "),n("li",[n("code",[e._v("container")]),e._v("：获取路径的容器（包含所有同级节点的数组）")]),e._v(" "),n("li",[n("code",[e._v("skip")]),e._v("：停止子节点的遍历")]),e._v(" "),n("li",[n("code",[e._v("stop")]),e._v("：停止整个路径的遍历")]),e._v(" "),n("li",[n("code",[e._v("replaceWith")]),e._v("：替换节点")]),e._v(" "),n("li",[n("code",[e._v("replaceWithMultiple")]),e._v("：用多节点替换单节点")]),e._v(" "),n("li",[n("code",[e._v("replaceWithSourceString")]),e._v("：用字符串源码替换节点")]),e._v(" "),n("li",[n("code",[e._v("insertBefore")]),e._v("：在当前节点之前插入兄弟节点")]),e._v(" "),n("li",[n("code",[e._v("insertAfter")]),e._v("：在当前节点之前插入兄弟节点")]),e._v(" "),n("li",[n("code",[e._v("unshiftContainer")]),e._v("：在节点容器的开始插入节点")]),e._v(" "),n("li",[n("code",[e._v("pushContainer")]),e._v("：在节点容器的结尾插入节点")]),e._v(" "),n("li",[n("code",[e._v("remove")]),e._v("：删除节点（自身）")])]),e._v(" "),n("p",[e._v("...")]),e._v(" "),n("p",[e._v("更多函数与使用方法参考"),n("code",[e._v("babel-handbook")]),e._v("。")]),e._v(" "),n("h1",{attrs:{id:"第一个babel插件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第一个babel插件","aria-hidden":"true"}},[e._v("#")]),e._v(" 第一个Babel插件")]),e._v(" "),n("p",[n("strong",[e._v("插件分析")])]),e._v(" "),n("p",[e._v("假设我想把所有的如下代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var hasBarProperty = foo.hasOwnProperty("bar");\nvar isPrototypeOfBar = foo.isPrototypeOf(bar);\nvar barIsEnumerable = foo.propertyIsEnumerable("bar");\n')])])]),n("p",[e._v("转换成这种写法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var hasBarProperty = Object.prototype.hasOwnProperty.call(foo, "bar");\nvar isPrototypeOfBar = Object.prototype.isPrototypeOf.call(foo, bar);\nvar barIsEnumerable = Object.prototype.propertyIsEnumerable.call(foo, "bar");\n')])])]),n("p",[e._v("这里主要目的是将"),n("code",[e._v("Object.prototype")]),e._v("上的方法调用，改成"),n("code",[e._v("Object.prototype.propertyIsEnumerable.call()")]),e._v("形式。")]),e._v(" "),n("p",[e._v("这里以转换"),n("code",[e._v("hasOwnProperty")]),e._v("为例，先在"),n("code",[e._v("astexplorer")]),e._v("观察待处理AST("),n("code",[e._v('foo.hasOwnProperty("bar")')]),e._v(")与目标AST("),n("code",[e._v('Object.prototype.hasOwnProperty.call(foo, "bar")')]),e._v(")结构。")]),e._v(" "),n("p",[e._v("待处理的"),n("code",[e._v('foo.hasOwnProperty("bar")')]),e._v("的AST大致如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('{\n    "type": "CallExpression",\n    "loc": {...},\n    "callee": {\n        "type": "MemberExpression",\n        "loc": {...},\n        "object": {\n            "type": "Identifier",\n            "loc": {...},\n            "name": "foo"\n        },\n        "property": {\n            "type": "Identifier",\n            "loc": {...},\n            "name": "hasOwnProperty"\n        },\n        "computed": false\n    },\n    "arguments": [\n        {\n            "type": "StringLiteral",\n            "loc": {...},\n            "value": "bar"\n        }\n    ]\n}\n')])])]),n("p",[e._v("期望转换为"),n("code",[e._v('Object.prototype.hasOwnProperty.call(foo, "bar")')]),e._v("的目标AST大致如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('\n{\n    "type": "CallExpression",\n    "loc": {...},\n    "callee": {\n        "type": "MemberExpression",\n        "loc": {...},\n        "object": {\n            "type": "MemberExpression",\n            "loc": {...},\n            "object": {\n                "type": "MemberExpression",\n                "loc": {...},\n                "object": {\n                    "type": "Identifier",\n                    "loc": {...},\n                    "name": "Object"\n                },\n                "property": {\n                    "type": "Identifier",,\n                    "loc": {...},\n                    "name": "prototype"\n                },\n                "computed": false\n            },\n            "property": {\n                "type": "Identifier",\n                "loc": {...},\n                "name": "hasOwnProperty"\n            },\n            "computed": false\n        },\n        "property": {\n            "type": "Identifier",\n            "loc": {...},\n            "name": "call"\n        },\n        "computed": false\n    },\n    "arguments": [\n        {\n            "type": "Identifier",\n            "loc": {...},\n            "name": "foo"\n        },\n        {\n            "type": "StringLiteral",\n            "loc": {... },\n            "value": "bar"\n        }\n    ]\n}\n')])])]),n("p",[e._v("根据如上两个AST，转换的大致思路为：")]),e._v(" "),n("ul",[n("li",[e._v("编写一个"),n("code",[e._v("CallExpression")]),e._v("访问者")]),e._v(" "),n("li",[e._v("获取"),n("code",[e._v("CallExpression.callee")]),e._v("，该节点为"),n("code",[e._v("MemberExpression")]),e._v("类型，代表属性调用表达式（即"),n("code",[e._v("foo.hasOwnProperty")]),e._v("部分）。")]),e._v(" "),n("li",[e._v("获取"),n("code",[e._v("CallExpression.arguments")]),e._v("，该节点是一个数组，代表参数部分（即"),n("code",[e._v('"bar"')]),e._v("部分）。")]),e._v(" "),n("li",[e._v("当"),n("code",[e._v("callee.object")]),e._v("为"),n("code",[e._v("Identifier")]),e._v("类型节点，并且"),n("code",[e._v("callee.property")]),e._v("为值为"),n("code",[e._v("hasOwnProperty")]),e._v("的"),n("code",[e._v("Identifier")]),e._v("节点时，则进行转换。")]),e._v(" "),n("li",[e._v("构造一个"),n("code",[e._v("Object.prototype.hasOwnProperty.call")]),e._v("形式的"),n("code",[e._v("MemberExpression")]),e._v("嵌套节点。")]),e._v(" "),n("li",[e._v("构造时，先构造最下面一层的"),n("code",[e._v("MemberExpression")]),e._v("节点，即"),n("code",[e._v("Object.prototype")]),e._v("部分，以此类推，构造完整的"),n("code",[e._v("Object.prototype.hasOwnProperty.call")]),e._v("。")]),e._v(" "),n("li",[e._v("然后再构造一个新的"),n("code",[e._v("CallExpression")]),e._v("节点，其中新的参数为原"),n("code",[e._v("CallExpression.callee.object")]),e._v("的值，与原参数组成的数组。")]),e._v(" "),n("li",[e._v("用新的"),n("code",[e._v("CallExpression")]),e._v("节点替换原来的节点。")])]),e._v(" "),n("p",[n("strong",[e._v("编写插件")])]),e._v(" "),n("p",[e._v("新建如下结构项目：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("--plugins\n  |--babel-plugin-transform-object-prototype-methods.js\n--index.js\n--.babelrc\n--package.json\n")])])]),n("p",[e._v("分别有如下代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// index.js\nvar hasBarProperty = foo.hasOwnProperty("bar");\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// plugins/babel-plugin-transform-object-prototype-methods.js\nmodule.exports = function (babel) {\n    const { types: t } = babel;\n    return {\n        name: "ast-transform", // not required\n        visitor: {\n          CallExpression(path) {\n              const memberExp = path.get("callee");\n              const arg = path.get("arguments.0");\n              const memberProperty = memberExp.get("property");\n              const memberObject = memberExp.get("object");\n              if (t.isIdentifier(memberProperty) && memberProperty.node.name === "hasOwnProperty") { // 对`hasOwnProperty`方法调用的节点进行转换\n                const objectMemberExp = t.MemberExpression(t.Identifier("Object"), t.Identifier("prototype")); // 构造`Object.prototype`的`MemberExpression`节点\n                const prototypeMemberExp = t.MemberExpression(objectMemberExp, t.Identifier("hasOwnProperty")); // 构造`Object.prototype.hasOwnProperty`的`MemberExpression`节点\n                const hasOwnPropertyMemberExp = t.MemberExpression(prototypeMemberExp, t.Identifier("call")); // 构造`Object.prototype.hasOwnProperty.call`的`MemberExpression`节点\n                const newCallExpression = t.callExpression(hasOwnPropertyMemberExp, [memberObject.node, arg.node]); // 构造`Object.prototype.hasOwnProperty.call(p, "bar")`的`callExpression`节点\n                path.replaceWith(newCallExpression); // 使用新节点替换\n              }\n            }\n        }\n    };\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// .babelrc\n{\n    "plugins": [\n        "./plugins/babel-plugin-transform-object-prototype-methods"\n    ]\n}\n')])])]),n("p",[e._v("在使用插件之前需要先安装依赖：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("yarn add @babel/core @babel/cli -D\n")])])]),n("p",[e._v("执行如下命令，使用"),n("code",[e._v("babel-plugin-transform-object-prototype-methods")]),e._v("插件转换代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("npx babel index.js -o output.js\n")])])]),n("p",[e._v("查看输出文件"),n("code",[e._v("output.js")]),e._v("：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var hasBarProperty = Object.prototype.hasOwnProperty.call(foo, "bar");\n')])])]),n("p",[e._v("源代码已经正确转换。")]),e._v(" "),n("p",[e._v("从上可知：")]),e._v(" "),n("ul",[n("li",[e._v("babel插件是一个函数。")]),e._v(" "),n("li",[e._v("该函数接受一个"),n("code",[e._v("babel")]),e._v("对象作为参数。")]),e._v(" "),n("li",[n("code",[e._v("babel.types")]),e._v("可直接使用"),n("code",[e._v("@babel/types")]),e._v("模块，在插件中不用单独引入。")]),e._v(" "),n("li",[e._v("在特定的类型访问者中，可以获取节点，以及添加、删除、替换节点等操作。")]),e._v(" "),n("li",[e._v("babel插件函数可以被"),n("code",[e._v(".babelrc")]),e._v("配置文件，或者命令行"),n("code",[e._v("--plugins")]),e._v("参数，或者"),n("code",[e._v("babel.transform")]),e._v("的"),n("code",[e._v("plugins")]),e._v("选项加载。")])]),e._v(" "),n("p",[n("strong",[e._v("完善插件功能")])]),e._v(" "),n("p",[e._v("下面来完善插件功能，让该插件可以处理"),n("code",[e._v("hasOwnProperty")]),e._v("、"),n("code",[e._v("isPrototypeOf")]),e._v("、"),n("code",[e._v("propertyIsEnumerable")]),e._v("三种类型。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// plugins/babel-plugin-transform-object-prototype-methods.js\nmodule.exports = function (babel) {\n  const { types: t } = babel;\n  const PropertySchema = {\n    hasOwnProperty: {\n      type: "boolean",\n      default: true\n    },\n    isPrototypeOf: {\n      type: "boolean",\n      default: true\n    },\n    propertyIsEnumerable: {\n      type: "boolean",\n      default: true\n    }\n  };\n\n  return {\n      name: "transform-object-prototype-methods", // not required\n      visitor: {\n        CallExpression(path) {\n            const memberExp = path.get("callee");\n            const arg = path.get("arguments.0");\n            const memberProperty = memberExp.get("property");\n            const memberObject = memberExp.get("object");\n            if (t.isIdentifier(memberProperty) && PropertySchema[memberProperty.node.name]) {\n              const objectMemberExp = t.MemberExpression(t.Identifier("Object"), t.Identifier("prototype"));\n              const prototypeMemberExp = t.MemberExpression(objectMemberExp, t.Identifier(memberProperty.node.name));\n              const callMemberExp = t.MemberExpression(prototypeMemberExp, t.Identifier("call"));\n              const newCallExpression = t.callExpression(callMemberExp, [memberObject.node, arg.node]);\n              path.replaceWith(newCallExpression);\n            }\n          }\n      }\n  };\n}\n')])])]),n("p",[e._v("现在以下代码均可正确转换：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var hasBarProperty = foo.hasOwnProperty("bar");\nvar isPrototypeOfBar = foo.isPrototypeOf(bar);\nvar barIsEnumerable = foo.propertyIsEnumerable("bar");\n\nif(foo.hasOwnProperty("bar")) {}\nif(foo.isPrototypeOf(bar)) {}\nif(foo.propertyIsEnumerable("bar")) {}\n')])])]),n("p",[n("strong",[e._v("插件选项")])]),e._v(" "),n("p",[e._v("下面我们让该插件可以接受插件选项，并根据选项开启或禁用转换：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('{\n    "plugins": [\n        ["./plugins/babel-plugin-transform-object-prototype-methods", {\n            "hasOwnProperty": true,\n            "isPrototypeOf": false\n        }]\n    ]\n}\n')])])]),n("p",[e._v("修改插件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('module.exports = function (babel) {\n  const { types: t } = babel;\n  const PropertySchema = {\n    hasOwnProperty: {\n      type: "boolean",\n      default: true\n    },\n    isPrototypeOf: {\n      type: "boolean",\n      default: true\n    },\n    propertyIsEnumerable: {\n      type: "boolean",\n      default: true\n    }\n  };\n\n  // 默认插件选项\n  const defaultOpts = {\n    hasOwnProperty: PropertySchema.hasOwnProperty.default,\n    isPrototypeOf: PropertySchema.isPrototypeOf.default,\n    propertyIsEnumerable: PropertySchema.propertyIsEnumerable.default\n  };\n\n  return {\n      name: "ast-transform", // not required\n      visitor: {\n        CallExpression(path, state) {\n            const memberExp = path.get("callee");\n            const arg = path.get("arguments.0");\n            const memberProperty = memberExp.get("property");\n            const memberObject = memberExp.get("object");\n            // 合并选项\n            const options = Object.assign({}, defaultOpts, state.opts);\n            const propertyName = memberProperty.node.name;\n            // 只有规定的`Object.prototype`原型方法，并且只有启用转换该原型方法时，才会被转换\n            if (t.isIdentifier(memberProperty) && PropertySchema[propertyName] && options[propertyName]) {\n              const objectMemberExp = t.MemberExpression(t.Identifier("Object"), t.Identifier("prototype"));\n              const prototypeMemberExp = t.MemberExpression(objectMemberExp, t.Identifier(propertyName));\n              const callMemberExp = t.MemberExpression(prototypeMemberExp, t.Identifier("call"));\n              const newCallExpression = t.callExpression(callMemberExp, [memberObject.node, arg.node]);\n              path.replaceWith(newCallExpression);\n            }\n          }\n      }\n  };\n}\n')])])]),n("p",[e._v("现在插件选项已经可以工作了，转换结果如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var hasBarProperty = Object.prototype.hasOwnProperty.call(foo, "bar");\nvar isPrototypeOfBar = foo.isPrototypeOf(bar);\nvar barIsEnumerable = Object.prototype.propertyIsEnumerable.call(foo, "bar");\n\nif (Object.prototype.hasOwnProperty.call(foo, "bar")) {}\n\nif (foo.isPrototypeOf(bar)) {}\n\nif (Object.prototype.propertyIsEnumerable.call(foo, "bar")) {}\n')])])]),n("p",[n("strong",[e._v("恭喜你，你已经开始你的大佬（装逼）之路了。")])])])},[],!1,null,null,null);t.default=a.exports}}]);